#!/usr/bin/env node

/**
 * GraphQL Validation Script
 * 
 * This script validates all GraphQL operations against the schema
 * and provides clear error messages for any issues found.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// ANSI color codes for better output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m',
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function checkSchemaAvailability() {
  const introspectionPath = path.join(process.cwd(), 'src/types/generated/introspection.json');
  
  if (!fs.existsSync(introspectionPath)) {
    log('‚ö†Ô∏è  Schema introspection not found. Running codegen first...', 'yellow');
    
    try {
      execSync('npm run codegen', { stdio: 'inherit' });
      log('‚úÖ Schema introspection generated successfully', 'green');
    } catch (error) {
      log('‚ùå Failed to generate schema introspection', 'red');
      log('Make sure your GraphQL server is running and accessible', 'yellow');
      process.exit(1);
    }
  }
}

function validateGraphQLFiles() {
  const graphqlDir = path.join(process.cwd(), 'src/graphql');
  const errors = [];
  const warnings = [];

  if (!fs.existsSync(graphqlDir)) {
    log('‚ö†Ô∏è  No GraphQL directory found', 'yellow');
    return { errors, warnings };
  }

  // Find all .graphql and .gql files
  const findGraphQLFiles = (dir) => {
    const files = [];
    const items = fs.readdirSync(dir);

    for (const item of items) {
      const fullPath = path.join(dir, item);
      const stat = fs.statSync(fullPath);

      if (stat.isDirectory()) {
        files.push(...findGraphQLFiles(fullPath));
      } else if (item.endsWith('.graphql') || item.endsWith('.gql')) {
        files.push(fullPath);
      }
    }

    return files;
  };

  const graphqlFiles = findGraphQLFiles(graphqlDir);
  
  if (graphqlFiles.length === 0) {
    log('‚ö†Ô∏è  No GraphQL operation files found', 'yellow');
    return { errors, warnings };
  }

  log(`üîç Validating ${graphqlFiles.length} GraphQL files...`, 'blue');

  // Basic syntax validation
  for (const filePath of graphqlFiles) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const relativePath = path.relative(process.cwd(), filePath);

      // Check for empty files
      if (!content.trim()) {
        warnings.push({
          file: relativePath,
          message: 'File is empty',
          type: 'EMPTY_FILE',
        });
        continue;
      }

      // Check for basic GraphQL syntax
      if (!content.includes('query') && !content.includes('mutation') && !content.includes('subscription') && !content.includes('fragment')) {
        errors.push({
          file: relativePath,
          message: 'File does not contain valid GraphQL operations',
          type: 'INVALID_OPERATION',
        });
        continue;
      }

      // Check for operation names
      const operationRegex = /(query|mutation|subscription)\s+(\w+)?/g;
      const matches = [...content.matchAll(operationRegex)];
      
      for (const match of matches) {
        if (!match[2]) {
          warnings.push({
            file: relativePath,
            message: `${match[1]} operation should have a name`,
            type: 'UNNAMED_OPERATION',
          });
        }
      }

      log(`  ‚úì ${relativePath}`, 'green');

    } catch (error) {
      errors.push({
        file: path.relative(process.cwd(), filePath),
        message: `Failed to read file: ${error.message}`,
        type: 'FILE_ERROR',
      });
    }
  }

  return { errors, warnings };
}

function checkTypeGeneration() {
  const generatedTypesPath = path.join(process.cwd(), 'src/types/generated/graphql.ts');
  
  if (!fs.existsSync(generatedTypesPath)) {
    return {
      error: 'Generated types not found. Run codegen first.',
    };
  }

  const content = fs.readFileSync(generatedTypesPath, 'utf8');
  
  // Check if it's still the placeholder
  if (content.includes('// This file will be generated by GraphQL Code Generator')) {
    return {
      error: 'Types are still placeholder. Schema introspection may have failed.',
    };
  }

  // Check for actual generated content
  if (!content.includes('export') || content.trim().length < 100) {
    return {
      error: 'Generated types appear to be incomplete.',
    };
  }

  return { success: true };
}

function main() {
  log('üöÄ Starting GraphQL validation...', 'cyan');
  
  // Step 1: Check schema availability
  checkSchemaAvailability();
  
  // Step 2: Check type generation
  const typeCheck = checkTypeGeneration();
  if (typeCheck.error) {
    log(`‚ùå Type generation issue: ${typeCheck.error}`, 'red');
    log('üí° Try running: npm run codegen', 'yellow');
    process.exit(1);
  }
  
  // Step 3: Validate GraphQL files
  const { errors, warnings } = validateGraphQLFiles();
  
  // Report results
  if (errors.length > 0) {
    log('\n‚ùå Validation Errors:', 'red');
    for (const error of errors) {
      log(`  ${error.file}: ${error.message}`, 'red');
    }
  }
  
  if (warnings.length > 0) {
    log('\n‚ö†Ô∏è  Validation Warnings:', 'yellow');
    for (const warning of warnings) {
      log(`  ${warning.file}: ${warning.message}`, 'yellow');
    }
  }
  
  // Summary
  log('\nüìä Validation Summary:', 'cyan');
  log(`  Errors: ${errors.length}`, errors.length > 0 ? 'red' : 'green');
  log(`  Warnings: ${warnings.length}`, warnings.length > 0 ? 'yellow' : 'green');
  
  if (errors.length > 0) {
    log('\n‚ùå GraphQL validation failed', 'red');
    process.exit(1);
  } else if (warnings.length > 0) {
    log('\n‚ö†Ô∏è  GraphQL validation completed with warnings', 'yellow');
  } else {
    log('\n‚úÖ All GraphQL operations are valid', 'green');
  }
}

// Run the validation
main();